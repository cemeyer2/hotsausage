to run benchmarks, load a terminal to this directory and execute:

./run-benchmarks.sh <src_file>

exampe:

chuck@silverstone:~/workspaces/workspace_hotsausage/hotsausage/benchmarks$ ./run-benchmarks.sh src/PrivacyBenchmarks-rhino.js

benchmarks are executed 3 times, at opt levels -1, 0, and 9:

according to the rhino website:

-1
Interpretive mode is always used. The compilation time is minimized at the expense of runtime performance. No class files are generated, which may improve memory usage depending on your system. Another benefit of the interpreted mode is that the interpreter performs tail-call elimination of recursive functions. Also, you must use this optimization level if your code uses Continuation objects.

0
No optimizations are performed. The bytecode compiler runs fastest in this mode, but the generated byte code is less efficient.

1-9
All optimizations are performed. Simple data and type flow analysis is performed to determine which JavaScript variables can be allocated to Java VM registers, and which variables are used only as Numbers. Local common sub-expressions are collapsed (currently this only happens for property lookup, but in the future more expressions may be optimized). All local variables and parameters are allocated to Java VM registers. Function call targets are speculatively pre-cached (based on the name used in the source) so that dispatching can be direct, pending runtime confirmation of the actual target. Arguments are passed as Object/Number pairs to reduce conversion overhead.